## Архитектурное решение системы

### Общая структура

Система реализована как набор независимых микросервисов, взаимодействующих между собой через API. Архитектура включает следующие компоненты:

* **Gateway-сервер** — точка входа для всех внешних запросов
* **Config-сервер** — централизованное хранение конфигураций
* **Discovery-сервер** — сервис обнаружения для автоматического обнаружения микросервисов
* **Основные микросервисы** — функциональные модули системы

### Микросервисы

Система состоит из следующих микросервисов:

* **User-сервис** — управление пользовательскими данными
* **Event-сервис** — работа с событиями
* **Request-сервис** — обработка заявок на участие
* **Comment-сервис** — управление комментариями
* **Interaction-API** — набор интерфейсов и утилит для взаимодействия между сервисами

### Взаимодействие компонентов

При запуске каждый микросервис:
* Регистрируется в **discovery-сервере**
* Загружает конфигурации из **config-сервера**
* Взаимодействует с другими сервисами через **gateway-сервер**

### API спецификации

#### User-сервис

* **Управление пользователями**
    * Получение списка всех пользователей: `GET /admin/users`
    * Поиск пользователя по ID: `GET /admin/users/{userId}`
    * Проверка существования пользователя: `GET /admin/{userId}`

#### Event-сервис

* **Работа с событиями**
    * Получение информации о событии: `GET /events/{id}`
    * Создание нового события: `POST /users/{userId}/events`
    * Обновление заявок: `PATCH /admin/events/{eventId}`
    * Проверка существования события: `GET /admin/events/{id}`

#### Request-сервис

* **Управление заявками**
    * Получение всех заявок пользователя: `GET /users/{userId}/requests`
    * Создание заявки: `POST /users/{userId}/requests`
    * Отмена заявки: `PATCH /users/{userId}/requests/{requestId}/cancel`
    * Поиск заявок по событию: `GET /requests/event/{eventId}`
    * Поиск подтвержденных заявок: `GET /requests/event/confirmed/{eventId}`
    * Изменение статуса заявки: `PATCH /requests/status/{id}`

#### Comment-сервис

* **Работа с комментариями**
    * Получение комментариев события: `GET /comments/{eventId}`
    * Создание комментария: `POST /users/{userId}/comments`
    * Обновление комментария: `PATCH /users/{userId}/comments/{commentId}`
    * Удаление комментария: `DELETE /users/{userId}/comments/{commentId}`

#### Stats-сервис

* **Статистика**
    * Получение общей статистики: `GET /stats`
    * Запись статистической информации: `POST /hit`

---

## Запуск проекта (через Docker Compose)

### Требования
- **Docker**
- **Docker Compose**
- Доступ к исходному коду (для сборки образов)

### 1. Сборка и запуск всей системы

```bash
# В корне репозитория (где лежит docker-compose.yml)
docker-compose up --build -d
```

> Первый запуск может занять **2–5 минут** из-за последовательной инициализации (healthcheck-зависимости).

### 2. Проверка состояния

```bash
# Посмотреть запущенные контейнеры
docker-compose ps

# Проверить логи конкретного сервиса (например, gateway)
docker-compose logs -f gateway-server
```

### 3. Остановка системы

```bash
docker-compose down
```

---

## Замечания для разработчиков

1. **Порядок запуска соблюдается автоматически**  
   Благодаря `depends_on` + `healthcheck`, сервисы стартуют только после готовности зависимостей.

2. **Изоляция БД**  
   Каждый микросервис работает со **своей собственной базой** — никакого shared database.

3. **Для локальной разработки**  
   Если вы хотите запустить **только один сервис** (например, `comment-service`) локально, убедитесь, что:
    - `discovery-server` и `config-server` работают (в Docker),
    - в `application.yml` указаны корректные адреса:
      ```yaml
      eureka:
        client:
          service-url:
            defaultZone: http://localhost:8761/eureka/
      ```
